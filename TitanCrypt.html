<!doctype html>
<html lang="sk">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ImgCrypt & TextCrypt (Pure JS)</title>
  <style>
    body { font-family: Arial, sans-serif; background:#0f1220; color:#eaf0ff; padding:20px; margin:0; }
    .card { background:#151823; padding:16px; border-radius:10px; border:1px solid #2b3440; max-width:900px; margin:0 auto; }
    label { display:block; margin-top:12px; color:#aab6d1; }
    input[type=text], textarea { width:100%; padding:8px; border-radius:6px; background:#0e1117; border:1px solid #26303b; color:#eaf0ff; }
    textarea { min-height:100px; resize:vertical; }
    .row { display:flex; gap:8px; margin-top:10px; align-items:end; }
    .row > * { flex:1; }
    button { padding:8px 10px; border-radius:6px; border:none; background:#2e8b57; color:white; cursor:pointer; }
    .small { padding:6px 8px; font-size:0.9rem; }
    .note { font-size:0.9rem; color:#97a6c2; margin-top:8px; }
    .img-preview-container {
      margin-top:8px;
      position: relative;
      display: inline-block;
      border:1px solid #26303b;
      border-radius:6px;
      overflow: hidden;
    }
    .img-preview {
      max-width:100%;
      display: block;
    }
    .flash { color:#ffcc66; margin-top:8px; }
    .dice-btn { 
      background:#4a5568; 
      padding:8px; 
      border-radius:6px; 
      cursor:pointer; 
      font-size:1.2rem;
      display:flex;
      align-items:center;
      justify-content:center;
      width:42px;
      height:42px;
    }
    .key-input-container {
      display: flex;
      gap: 8px;
      align-items: end;
      margin-top: 8px;
    }
    .key-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .file-input-container {
      display: flex;
      gap: 8px;
      align-items: end;
    }
    .error-message {
      color: #ff6b6b;
      font-size: 0.85rem;
      margin-top: 4px;
      display: none;
      align-items: center;
      gap: 4px;
    }
    .error-icon {
      font-weight: bold;
    }
    .section { margin-top: 24px; border-top: 1px solid #28313e; padding-top: 24px; }
    .copy-text-btn {
      background:#4a5568;
      padding:6px 10px;
      border-radius:4px;
      cursor:pointer;
      font-size:0.9rem;
      margin-top:8px;
    }
    #decrypted-image-container { margin-top:16px; }
  </style>
</head>
<body>
  <div class="card">
    <h2>ImgCrypt</h2>

    <h3>1) ≈†ifrovanie obr√°zka ‚Üí s√∫bory</h3>
    <form id="encryptForm">
      <label>Vyber obr√°zok (PNG odpor√∫ƒçan√©):</label>
      <input type="file" id="encrypt-image-input" accept="image/*" required>
      <label>Kƒæ√∫ƒç (A‚ÄìZ, 0‚Äì9; presne 25 znakov):</label>
      <div class="key-input-container">
        <input type="text" id="encrypt-key" placeholder="Napr. ABC12..." required
               oninput="validateKey('encrypt-key', 'encrypt-key-error')" maxlength="29">
        <div class="key-buttons">
          <button type="button" class="dice-btn" onclick="generateAndSetKey('encrypt-key')">üé≤</button>
          <button class="copy-btn small" type="button" onclick="copyKey('encrypt-key')">üìã Kop√≠rova≈•</button>
        </div>
        <button class="small" type="button" onclick="encryptImage()">Za≈°ifrova≈•</button>
      </div>
      <div class="error-message" id="encrypt-key-error">
        <span class="error-icon">!</span>
        <span>Kƒæ√∫ƒç mus√≠ obsahova≈• presne 25 znakov (A-Z, 0-9)</span>
      </div>
      <div class="note">Pomlƒçky sa automaticky vkladaj√∫ ka≈æd√Ωch 5 znakov. Kƒæ√∫ƒç mus√≠ ma≈• presne 25 znakov.</div>
    </form>

    <div id="encrypt-output"></div>

    <hr style="margin-top:16px; border-color:#28313e">

    <h3>2) De≈°ifrovanie s√∫borov ‚Üí obr√°zok</h3>
    <form id="decryptForm">
      <label>Nahraj za≈°ifrovan√Ω obr√°zok (.png):</label>
      <input type="file" id="decrypt-image-input" accept=".png" required>
      <label>Nahraj de≈°ifrovac√≠ kƒæ√∫ƒç (.key):</label>
      <input type="file" id="decrypt-key-file" accept=".key" required>
      <label>Kƒæ√∫ƒç (A‚ÄìZ, 0‚Äì9; presne 25 znakov):</label>
      <div class="key-input-container">
        <input type="text" id="decrypt-key" placeholder="Vlo≈æ kƒæ√∫ƒç pre de≈°ifrovanie" required
               oninput="validateKey('decrypt-key', 'decrypt-key-error')" maxlength="29">
        <div class="key-buttons">
          <button class="copy-btn small" type="button" onclick="copyKey('decrypt-key')">üìã Kop√≠rova≈•</button>
        </div>
        <button class="small" type="button" onclick="decryptImage()">De≈°ifrova≈•</button>
      </div>
      <div class="error-message" id="decrypt-key-error">
        <span class="error-icon">!</span>
        <span>Kƒæ√∫ƒç mus√≠ obsahova≈• presne 25 znakov (A-Z, 0-9)</span>
      </div>
    </form>

    <div id="decrypted-image-container"></div>
  </div>

  <div class="card section">
    <h2>TextCrypt</h2>
    
    <form id="textEncryptForm">
      <label>Kƒæ√∫ƒç (A‚ÄìZ, 0‚Äì9; presne 25 znakov):</label>
      <div class="key-input-container">
        <input type="text" id="text-key" placeholder="Napr. ABC12..." required
               oninput="validateKey('text-key', 'text-key-error')" maxlength="29">
        <div class="key-buttons">
          <button type="button" class="dice-btn" onclick="generateAndSetKey('text-key')">üé≤</button>
          <button class="copy-btn small" type="button" onclick="copyKey('text-key')">üìã Kop√≠rova≈•</button>
        </div>
      </div>
      <div class="error-message" id="text-key-error">
        <span class="error-icon">!</span>
        <span>Kƒæ√∫ƒç mus√≠ obsahova≈• presne 25 znakov (A-Z, 0-9)</span>
      </div>
      
      <label>Text na za≈°ifrovanie (podporuje diakritiku):</label>
      <textarea id="plain-text" placeholder="Zadaj text na za≈°ifrovanie..." required></textarea>
      
      <button class="small" type="button" onclick="encryptText()">Za≈°ifrova≈• text</button>
    </form>

    <div id="text-encrypt-output"></div>
    
    <hr style="margin-top:24px; border-color:#28313e">
    
    <form id="textDecryptForm">
      <label>Kƒæ√∫ƒç (A‚ÄìZ, 0‚Äì9; presne 25 znakov):</label>
      <div class="key-input-container">
        <input type="text" id="decrypt-text-key" placeholder="Napr. ABC12..." required
               oninput="validateKey('decrypt-text-key', 'decrypt-text-key-error')" maxlength="29">
        <div class="key-buttons">
          <button class="copy-btn small" type="button" onclick="copyKey('decrypt-text-key')">üìã Kop√≠rova≈•</button>
        </div>
      </div>
      <div class="error-message" id="decrypt-text-key-error">
        <span class="error-icon">!</span>
        <span>Kƒæ√∫ƒç mus√≠ obsahova≈• presne 25 znakov (A-Z, 0-9)</span>
      </div>
      
      <label>Za≈°ifrovan√Ω text na de≈°ifrovanie:</label>
      <textarea id="encrypted-text-input" placeholder="Vlo≈æ za≈°ifrovan√Ω text na de≈°ifrovanie..." required></textarea>
      
      <button class="small" type="button" onclick="decryptText()" style="background:#8b5cf6;">De≈°ifrova≈• text</button>
    </form>

    <div id="text-decrypt-output"></div>
  </div>

  <script>
    // Utility: normalize key
    function normalizeKey(raw) {
      if (!raw) return "";
      return raw.replace(/[^A-Z0-9]/g, '').toUpperCase().substring(0, 25);
    }

    // Utility: format key with dashes
    function formatKeyInput(id) {
      const input = document.getElementById(id);
      let value = input.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
      if (value.length > 25) value = value.substring(0, 25);
      const formatted = value.match(/.{1,5}/g)?.join('-') || '';
      input.value = formatted;
    }

    // Validation
    function validateKey(inputId, errorId) {
      formatKeyInput(inputId);
      const clean = normalizeKey(document.getElementById(inputId).value);
      const errorEl = document.getElementById(errorId);
      if (clean.length !== 25) {
        errorEl.style.display = 'flex';
        return false;
      } else {
        errorEl.style.display = 'none';
        return true;
      }
    }

    // Generate random key
    function generateRandomKey() {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let result = "";
      for (let i = 0; i < 25; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    function generateAndSetKey(inputId) {
      const key = generateRandomKey();
      document.getElementById(inputId).value = key.match(/.{1,5}/g).join('-');
      validateKey(inputId, inputId + '-error');
    }

    function copyKey(inputId) {
      const input = document.getElementById(inputId);
      input.select();
      document.execCommand('copy');
      alert('Kƒæ√∫ƒç bol skop√≠rovan√Ω do schr√°nky!');
    }

    // === TEXT ENCRYPTION ===
    function xorBytes(data, key) {
      const result = new Uint8Array(data.length);
      for (let i = 0; i < data.length; i++) {
        result[i] = data[i] ^ key[i % key.length];
      }
      return result;
    }

    function encryptText() {
      const keyRaw = document.getElementById('text-key').value;
      const plain = document.getElementById('plain-text').value;
      if (!validateKey('text-key', 'text-key-error')) return;
      if (!plain.trim()) { alert("Zadaj text na za≈°ifrovanie."); return; }

      const keyClean = normalizeKey(keyRaw);
      const textBytes = new TextEncoder().encode(plain);
      const keyBytes = new TextEncoder().encode(keyClean);
      const encryptedBytes = xorBytes(textBytes, keyBytes);
      const hex = Array.from(encryptedBytes).map(b => b.toString(16).padStart(2, '0')).join('');
      const lengthHex = (textBytes.length).toString(16).padStart(4, '0');
      const fullHex = lengthHex + hex;

      const output = document.getElementById('text-encrypt-output');
      output.innerHTML = `
        <hr style="margin-top:16px; border-color:#28313e">
        <h3>Za≈°ifrovan√Ω text:</h3>
        <textarea id="encrypted-text-display" readonly rows="4">${fullHex}</textarea>
        <button class="copy-text-btn" onclick="copyTextArea('encrypted-text-display')">üìã Kop√≠rova≈• za≈°ifrovan√Ω text</button>
        <div class="note" style="margin-top:8px;">
          Dƒ∫≈æka p√¥vodn√©ho textu: ${plain.length} znakov | 
          Dƒ∫≈æka za≈°ifrovan√©ho textu: ${fullHex.length} znakov
        </div>
      `;
    }

    function decryptText() {
      const keyRaw = document.getElementById('decrypt-text-key').value;
      const encHex = document.getElementById('encrypted-text-input').value.trim();
      if (!validateKey('decrypt-text-key', 'decrypt-text-key-error')) return;
      if (!encHex) { alert("Zadaj za≈°ifrovan√Ω text."); return; }

      if (!/^[0-9a-fA-F]+$/.test(encHex)) {
        alert("Neplatn√Ω za≈°ifrovan√Ω text ‚Äì mus√≠ by≈• hexadecim√°lny.");
        return;
      }
      if (encHex.length < 4) {
        alert("Ch√Ωba inform√°cia o dƒ∫≈æke textu.");
        return;
      }

      const keyClean = normalizeKey(keyRaw);
      const lengthHex = encHex.substring(0, 4);
      const originalByteLength = parseInt(lengthHex, 16);
      const encryptedHex = encHex.substring(4);
      const encryptedBytes = new Uint8Array(originalByteLength);
      for (let i = 0; i < originalByteLength; i++) {
        const hexByte = encryptedHex.substr(i * 2, 2);
        if (!hexByte) break;
        encryptedBytes[i] = parseInt(hexByte, 16);
      }

      const keyBytes = new TextEncoder().encode(keyClean);
      const decryptedBytes = xorBytes(encryptedBytes, keyBytes);
      let decryptedText;
      try {
        decryptedText = new TextDecoder('utf-8').decode(decryptedBytes);
      } catch (e) {
        alert("Chyba pri de≈°ifrovan√≠: neplatn√Ω kƒæ√∫ƒç alebo po≈°koden√Ω text.");
        return;
      }

      const output = document.getElementById('text-decrypt-output');
      output.innerHTML = `
        <hr style="margin-top:16px; border-color:#28313e">
        <h3>De≈°ifrovan√Ω text:</h3>
        <textarea id="decrypted-text-display" readonly rows="4">${decryptedText}</textarea>
        <button class="copy-text-btn" onclick="copyTextArea('decrypted-text-display')">üìã Kop√≠rova≈• de≈°ifrovan√Ω text</button>
      `;
    }

    function copyTextArea(id) {
      const ta = document.getElementById(id);
      ta.select();
      document.execCommand('copy');
      alert('Text bol skop√≠rovan√Ω do schr√°nky!');
    }

    // === IMAGE ENCRYPTION ===
    async function encryptImage() {
      const fileInput = document.getElementById('encrypt-image-input');
      const file = fileInput.files[0];
      if (!file) { alert("Vyber obr√°zok."); return; }
      if (!validateKey('encrypt-key', 'encrypt-key-error')) return;

      const keyRaw = document.getElementById('encrypt-key').value;
      const keyClean = normalizeKey(keyRaw);

      const img = new Image();
      const url = URL.createObjectURL(file);
      img.src = url;
      await new Promise(resolve => img.onload = resolve);

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = new Uint8Array(imageData.data);

      // Create shuffle mapping
      const total = canvas.width * canvas.height;
      const indices = Array.from({length: total}, (_, i) => i);
      const seed = keyClean.split('').reduce((a, c) => a + c.charCodeAt(0), 0) % (2**32);
      seededShuffle(indices, seed);

      // Shuffle pixels
      const shuffled = new Uint8ClampedArray(pixels.length);
      for (let i = 0; i < total; i++) {
        const srcIdx = indices[i] * 4;
        const dstIdx = i * 4;
        shuffled[dstIdx] = pixels[srcIdx];
        shuffled[dstIdx+1] = pixels[srcIdx+1];
        shuffled[dstIdx+2] = pixels[srcIdx+2];
        shuffled[dstIdx+3] = pixels[srcIdx+3];
      }

      const shuffledImgData = new ImageData(shuffled, canvas.width, canvas.height);
      ctx.putImageData(shuffledImgData, 0, 0);

      // Create encrypted image blob
      canvas.toBlob(async (blob) => {
        const reader = new FileReader();
        reader.onload = async () => {
          const shuffledBytes = new Uint8Array(reader.result);

          // Build key data: "width:height:idx1,idx2,..."
          const mappingStr = `${canvas.width}:${canvas.height}:${indices.join(',')}`;
          const mappingBytes = new TextEncoder().encode(mappingStr);
          const userKeyBytes = new TextEncoder().encode(keyClean);
          const encryptedKeyBytes = xorBytes(mappingBytes, userKeyBytes);

          // Download files
          downloadBlob(blob, "encrypted_image.png");
          downloadArrayBuffer(encryptedKeyBytes, "decryption_key.key");

          document.getElementById('encrypt-output').innerHTML = `
            <div class="flash">≈†ifrovanie √∫spe≈°n√©! Oba s√∫bory boli stiahnut√©.</div>
            <div class="note">Ulo≈æ si oba s√∫bory! Bez de≈°ifrovacieho kƒæ√∫ƒça nebude mo≈æn√© obr√°zok obnovi≈•.</div>
          `;
        };
        reader.readAsArrayBuffer(blob);
      }, 'image/png');
    }

    async function decryptImage() {
      const imgFile = document.getElementById('decrypt-image-input').files[0];
      const keyFile = document.getElementById('decrypt-key-file').files[0];
      if (!imgFile || !keyFile) { alert("Nahraj oba s√∫bory."); return; }
      if (!validateKey('decrypt-key', 'decrypt-key-error')) return;

      const userKeyRaw = document.getElementById('decrypt-key').value;
      const userKeyClean = normalizeKey(userKeyRaw);

      // Read key file
      const keyArrayBuffer = await readFileAsArrayBuffer(keyFile);
      const userKeyBytes = new TextEncoder().encode(userKeyClean);
      const decryptedKeyBytes = xorBytes(new Uint8Array(keyArrayBuffer), userKeyBytes);
      const keyStr = new TextDecoder().decode(decryptedKeyBytes);

      const parts = keyStr.split(':', 3);
      if (parts.length !== 3) { alert("Neplatn√Ω form√°t kƒæ√∫ƒça."); return; }
      const width = parseInt(parts[0]);
      const height = parseInt(parts[1]);
      const indices = parts[2].split(',').map(x => parseInt(x));

      // Read image
      const imgArrayBuffer = await readFileAsArrayBuffer(imgFile);
      const imgBlob = new Blob([imgArrayBuffer], {type: 'image/png'});
      const img = new Image();
      const url = URL.createObjectURL(imgBlob);
      img.src = url;
      await new Promise(resolve => img.onload = resolve);

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const shuffledPixels = new Uint8Array(imageData.data);

      // Inverse mapping
      const inverse = new Array(indices.length);
      for (let newPos = 0; newPos < indices.length; newPos++) {
        inverse[indices[newPos]] = newPos;
      }

      // Restore original pixels
      const original = new Uint8ClampedArray(shuffledPixels.length);
      const total = width * height;
      for (let i = 0; i < total; i++) {
        const srcIdx = inverse[i] * 4;
        const dstIdx = i * 4;
        original[dstIdx] = shuffledPixels[srcIdx];
        original[dstIdx+1] = shuffledPixels[srcIdx+1];
        original[dstIdx+2] = shuffledPixels[srcIdx+2];
        original[dstIdx+3] = shuffledPixels[srcIdx+3];
      }

      const originalImgData = new ImageData(original, width, height);
      ctx.putImageData(originalImgData, 0, 0);

      const restoredUrl = canvas.toDataURL('image/png');
      document.getElementById('decrypted-image-container').innerHTML = `
        <hr>
        <h3>De≈°ifrovan√Ω obr√°zok</h3>
        <div class="img-preview-container">
          <img src="${restoredUrl}" class="img-preview" alt="De≈°ifrovan√Ω obr√°zok">
          <a href="${restoredUrl}" download="decrypted_image.png" class="download-btn-overlay">
            <button class="small" style="padding:4px 8px;font-size:0.8rem;position:absolute;top:8px;right:8px;background:rgba(21,24,35,0.9);border:1px solid #2b3440;border-radius:4px;">Stiahnu≈•</button>
          </a>
        </div>
      `;
    }

    // Helpers
    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadArrayBuffer(buffer, filename) {
      const blob = new Blob([buffer], {type: 'application/octet-stream'});
      downloadBlob(blob, filename);
    }

    // Seeded shuffle (Fisher-Yates)
    function seededShuffle(array, seed) {
      let m = array.length;
      let t, i;
      while (m) {
        i = Math.floor(seededRandom(seed) * m--);
        t = array[m];
        array[m] = array[i];
        array[i] = t;
        seed = (seed * 16807) % 2147483647;
      }
    }

    function seededRandom(seed) {
      seed = (seed * 16807) % 2147483647;
      return seed / 2147483647;
    }

    // Format on input
    document.querySelectorAll('input[type="text"]').forEach(el => {
      el.addEventListener('input', function() {
        const id = this.id;
        if (id.includes('key')) {
          formatKeyInput(id);
        }
      });
    });
  </script>
</body>
</html>